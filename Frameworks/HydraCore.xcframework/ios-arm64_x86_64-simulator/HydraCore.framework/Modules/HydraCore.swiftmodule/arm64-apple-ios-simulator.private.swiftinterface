// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-bare-slash-regex -module-name HydraCore
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AdSupport
import AppTrackingTransparency
import Combine
import CommonCrypto
import CoreData
import CoreTelephony
import CryptoKit
import DeveloperToolsSupport
import Foundation
@_exported import HydraCore
import Network
import Security
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
@_hasMissingDesignatedInitializers public class HydraAES256CryptoManager {
  @objc deinit
}
extension Foundation.NSError {
  public static var HydraConfigurationError: Foundation.NSError
}
public protocol DeviceIdentifiersGenerator {
  var deviceID: Swift.String? { get }
  var advertisingID: Swift.String? { get }
  var devicePushToken: Swift.String? { get set }
  var interfaceID: Foundation.Data? { get set }
  func getInterfaceID() async -> Swift.String?
}
public class DeviceIdentifiers : HydraCore.DeviceIdentifiersGenerator {
  public var devicePushToken: Swift.String?
  public var interfaceID: Foundation.Data?
  public var deviceID: Swift.String?
  public var advertisingID: Swift.String? {
    get
  }
  public init(devicePushToken: Swift.String? = nil, interfaceID: Foundation.Data? = nil)
  public func getInterfaceID() async -> Swift.String?
  public static func systemValues() -> any HydraCore.DeviceIdentifiersGenerator
  @objc deinit
}
@_Concurrency.MainActor @preconcurrency public struct HydraGifImageView : SwiftUI.UIViewRepresentable {
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ uiView: WebKit.WKWebView, context: HydraCore.HydraGifImageView.Context)
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context: HydraCore.HydraGifImageView.Context) -> WebKit.WKWebView
  public typealias Body = Swift.Never
  public typealias Coordinator = Swift.Void
  public typealias UIViewType = WebKit.WKWebView
}
extension HydraCore.BaseRepository {
  public func fetch(predicate: Foundation.NSPredicate? = nil, sortDescriptors: [Foundation.NSSortDescriptor]? = nil, limit: Swift.Int? = nil, batchSize: Swift.Int? = nil, completion: @escaping HydraCore.DatabaseFetchRecordsCompletionHandler<T>)
  public func insert(values: [Swift.String : Any], completion: HydraCore.DatabaseCompletionHandler? = nil)
  public func delete(record: T, completion: HydraCore.DatabaseCompletionHandler? = nil)
  public func batchDelete(request: CoreData.NSFetchRequest<any CoreData.NSFetchRequestResult>, completion: HydraCore.DatabaseCompletionHandler? = nil)
}
public enum HydraDomain {
  case core(Swift.String)
  case events(Swift.String)
  case notification(Swift.String)
  case authentication(Swift.String)
  case imageDownloader(Swift.String)
  case inbox(Swift.String)
  case pullApproach(Swift.String)
}
public struct HydraDomainFactory {
  public static let NetworkManager: Swift.String
  public static let EventManager: Swift.String
  public static let EventScheduler: Swift.String
  public static let CoreDB: Swift.String
  public static let Notifications: Swift.String
  public static let Authentication: Swift.String
  public static let ImageDownloader: Swift.String
  public static let inbox: Swift.String
  public static let PullApproach: Swift.String
  public static func getDomain(for component: Swift.String) -> Swift.String
}
public protocol TelephonyInfoGenerator {
  static func getCarrier() -> CoreTelephony.CTCarrier?
  static func getCarrierName() -> Swift.String?
  static func getCountryCode() -> Swift.String?
}
public enum TelephonyData : HydraCore.TelephonyInfoGenerator {
  public static func getCarrier() -> CoreTelephony.CTCarrier?
  public static func getCarrierName() -> Swift.String?
  public static func getCountryCode() -> Swift.String?
}
public protocol DeviceHardwareInfoGenerator {
  var deviceModel: Swift.String { get }
  var deviceBrand: Swift.String { get }
  var carrierName: Swift.String? { get }
  var deviceID: Swift.String? { get }
}
public struct DeviceHardwareInfo : HydraCore.DeviceHardwareInfoGenerator {
  public var deviceModel: Swift.String {
    get
  }
  public var deviceBrand: Swift.String {
    get
  }
  public var carrierName: Swift.String? {
    get
  }
  public var deviceID: Swift.String? {
    get
  }
  public static func systemValues() -> any HydraCore.DeviceHardwareInfoGenerator
}
extension HydraCore.DeviceHardwareInfoGenerator where Self == HydraCore.DeviceHardwareInfo {
  public init(deviceModel: Swift.String = HydraConstants.DeviceInfo.deviceModel, deviceBrand: Swift.String = HydraConstants.DeviceInfo.brand, carrierName: Swift.String? = TelephonyData.getCarrierName(), deviceID: Swift.String? = HydraConstants.DeviceInfo.deviceID)
}
public protocol DeviceScreenInfoGenerator {
  var screenWidth: Swift.Int { get set }
  var screenHeight: Swift.Int { get set }
  func update(with screenInfo: (any HydraCore.DeviceScreenInfoGenerator)?)
}
@_hasMissingDesignatedInitializers public class DeviceScreenInfo : HydraCore.DeviceScreenInfoGenerator {
  public var screenHeight: Swift.Int
  public var screenWidth: Swift.Int
  public func update(with screenInfo: (any HydraCore.DeviceScreenInfoGenerator)?)
  @objc deinit
}
extension HydraCore.DeviceScreenInfoGenerator where Self == HydraCore.DeviceScreenInfo {
  public init(screenHeight: Swift.Int = HydraConstants.DeviceInfo.screenHeight, screenWidth: Swift.Int = HydraConstants.DeviceInfo.screenWidth)
}
extension Foundation.Data {
  public var toBase64String: Swift.String {
    get
  }
  public var isImageData: Swift.Bool {
    get
  }
  public func decrypt() -> Foundation.Data?
  public func encrypt() -> Foundation.Data?
}
public protocol DeviceDataGenerator : HydraCore.DeviceHardwareInfoGenerator, HydraCore.DeviceScreenInfoGenerator, HydraCore.OSInfoGenerator {
}
public class DeviceData : HydraCore.DeviceDataGenerator {
  public var deviceID: Swift.String? {
    get
  }
  public var osName: Swift.String {
    get
  }
  public var osVersion: Swift.String {
    get
  }
  public var deviceModel: Swift.String {
    get
  }
  public var deviceBrand: Swift.String {
    get
  }
  public var carrierName: Swift.String? {
    get
  }
  public var screenWidth: Swift.Int
  public var screenHeight: Swift.Int
  public init()
  public func update(with screenInfo: (any HydraCore.DeviceScreenInfoGenerator)?)
  @objc deinit
}
extension Swift.String {
  public var toData: Foundation.Data {
    get
  }
  public func color() -> SwiftUICore.Color?
  public func toJson() -> HydraCore.JSONDictionary?
}
extension HydraCore.HydraConstants {
  public enum DeviceInfo {
    public static let brand: Swift.String
    public static let osName: Swift.String
    public static let osVersion: Swift.String
    public static let deviceModel: Swift.String
    public static let deviceID: Swift.String
    public static let advertizingID: Swift.String
    public static let screenHeight: Swift.Int
    public static let screenWidth: Swift.Int
  }
}
extension CoreFoundation.CGFloat {
  public var intValue: Swift.Int {
    get
  }
}
public typealias DBFactory = HydraCore.HydraDBFactory
public enum HydraDBFactory {
  public static func generateDescriptions(forStore store: Swift.String, shouldInferMappingModelAutomatically inferMappingModelAutomatically: Swift.Bool = true, type: HydraCore.DBStorageType = .persistent, sharedAppGroupIdentifier: Swift.String? = nil) -> [CoreData.NSPersistentStoreDescription]?
  public static func generatePersistent(container name: Swift.String, withDescriptions descriptions: [CoreData.NSPersistentStoreDescription]?, andMOM mom: CoreData.NSManagedObjectModel, sharedAppGroupIdentifier: Swift.String? = nil) -> Swift.Result<CoreData.NSPersistentContainer, HydraCore.HydraError>
  public static func getRepositoryFor<T>(entity: T.Type, inStore store: Swift.String, withModel model: CoreData.NSManagedObjectModel) -> HydraCore.BaseRepository<T> where T : CoreData.NSManagedObject
  public static func getRepositoryFor<T>(entity: T.Type, inStore store: Swift.String, withModel model: CoreData.NSManagedObjectModel, configuredForEnv env: HydraCore.Env, shouldInferMappingModelAutomatically inferMappingModelAutomatically: Swift.Bool = true, sharedAppGroupIdentifier: Swift.String? = nil) -> HydraCore.BaseRepository<T> where T : CoreData.NSManagedObject
}
extension Foundation.UserDefaults {
  public func setPromotionalPushOpted(status: Swift.Bool = false)
  public func setTransactionalPushOpted(status: Swift.Bool = false)
  public func userSignInStatus() -> Swift.Bool
  public func userSignUpStatus() -> Swift.Bool
  public func userSignOutStatus() -> Swift.Bool
  public func promoPushOptedStatus() -> Swift.Bool
  public func transactionalPushOptedStatus() -> Swift.Bool
  public func pushOptedStatus() -> Swift.Bool
}
extension Foundation.UserDefaults {
  public func setCustomerId(cuid: Swift.String)
  public func customerId() -> Swift.String?
  public func removeCustomerId()
  public func setGuestLogin()
  public func invalidateGuestLogin()
  public func isGuestLogin() -> Swift.Bool
}
extension Foundation.UserDefaults {
  public func setLastSyncTime(_ time: Foundation.TimeInterval?)
  public func getLastSyncTime() -> Foundation.TimeInterval?
}
extension Foundation.UserDefaults {
  public func setInboxOpted(_ opted: Swift.Bool)
  public func getInboxOpted() -> Swift.Bool
}
extension Foundation.UserDefaults {
  public func setServerConfig(config: HydraCore.ServerConfig, account: Swift.String)
  public func getServerConfig(account: Swift.String) -> HydraCore.ServerConfig?
}
public protocol HydraAPIRequestGenerator {
  var baseURL: Swift.String { get }
  var sslKeyHash: Swift.String { get }
  var path: Swift.String { get }
  var method: HydraCore.HTTPMethod { get set }
  var header: [Swift.String : Swift.String]? { get set }
  var body: Foundation.Data? { get set }
  var timeOut: Foundation.TimeInterval { get set }
  var shouldSendAccessToken: Swift.Bool { get set }
  var accountId: Swift.String { get set }
  func getAccessToken() async -> Swift.String
}
extension HydraCore.HydraAPIRequestGenerator {
  public var url: Foundation.URL? {
    get
  }
  public mutating func asUrlRequest() async -> Foundation.URLRequest?
  public var baseURL: Swift.String {
    get
  }
  public var sslKeyHash: Swift.String {
    get
  }
  public func getAccessToken() async -> Swift.String
}
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  public static func sleep(seconds: Swift.Double) async throws
}
public enum ServerConfig : Swift.Codable {
  case server1
  case genericServer(Swift.String, Swift.String, [Foundation.TimeInterval])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol OSInfoGenerator {
  var osName: Swift.String { get }
  var osVersion: Swift.String { get }
}
public struct DeviceOSInfo : HydraCore.OSInfoGenerator {
  public var osName: Swift.String {
    get
  }
  public var osVersion: Swift.String {
    get
  }
  public static func systemValues() -> any HydraCore.OSInfoGenerator
}
extension HydraCore.OSInfoGenerator where Self == HydraCore.DeviceOSInfo {
  public init(osName: Swift.String = HydraConstants.DeviceInfo.osName, osVersion: Swift.String = HydraConstants.DeviceInfo.osVersion)
}
public class ImageLoader : Combine.ObservableObject {
  @Combine.Published @_projectedValueProperty($newImage) public var newImage: UIKit.UIImage? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  public var $newImage: Combine.Published<UIKit.UIImage?>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($gifImage) public var gifImage: HydraCore.HydraGifImageView? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  public var $gifImage: Combine.Published<HydraCore.HydraGifImageView?>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  public init(with placeholderImage: UIKit.UIImage? = nil)
  public func downloadImage(with imageURL: Foundation.URL?, imageIdentifier identifier: Swift.String?, asynchronousDownload async: Swift.Bool)
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
public protocol HydraInboxCoreProtocol : AnyObject {
  func getCurrentNotificationList() -> [HydraCore.HydraNotificationPayload]
  func refreshNotificationList()
}
extension Swift.Dictionary {
  public func nullableJSONData() -> Foundation.Data?
  public func JSONData() throws -> Foundation.Data
}
@_inheritsConvenienceInitializers @objc(HydraLog) public class HydraLog : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
public protocol HydraResponseGenerator {
  var rcvdData: Foundation.Data? { get set }
  var error: HydraCore.HydraError? { get set }
}
@objc public class HydraResponse : ObjectiveC.NSObject, HydraCore.HydraResponseGenerator {
  public var rcvdData: Foundation.Data?
  public var error: HydraCore.HydraError?
  public init(rcvdData: Foundation.Data?, error: HydraCore.HydraError?)
  @objc deinit
}
public enum HydraDatabaseError : Swift.Error, Swift.Equatable {
  case insertOperationError
  case deleteOperationError
  case fetchOperationError
  case saveOperationError
  case duplicateEntryError
  case updateOperationError
  public var code: Swift.Int {
    get
  }
  public func error(errorDescription: Swift.String) -> HydraCore.HydraError
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: HydraCore.HydraDatabaseError, b: HydraCore.HydraDatabaseError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum HydraAuthFlowError : Swift.Error, Swift.Equatable {
  case accountIdNotFound
  case clientIdOrClientSecretNotFound
  case testConfig
  case invalidAPIResponse
  case noResponse
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: HydraCore.HydraAuthFlowError, b: HydraCore.HydraAuthFlowError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension HydraCore.HydraAuthFlowError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum HydraFileManagerError : Foundation.LocalizedError {
  case filePathNotAvailable
  case unableToCreateDirectory
  public func error(errorDescription: Swift.String) -> HydraCore.HydraError
  public static func == (a: HydraCore.HydraFileManagerError, b: HydraCore.HydraFileManagerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum HydraImageDownloadError : Foundation.LocalizedError {
  case invalidImageData
  case imageDownloadingFailed
  case internetConnectionNotAvailable
  public func error(errorDescription: Swift.String) -> HydraCore.HydraError
  public var code: Swift.Int {
    get
  }
  public static func == (a: HydraCore.HydraImageDownloadError, b: HydraCore.HydraImageDownloadError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum HydraInboxError : Foundation.LocalizedError {
  case inboxConfigurationNotAvailable
  case receivedInvalidNotification
  public func error(errorDescription: Swift.String) -> HydraCore.HydraError
  public var code: Swift.Int {
    get
  }
  public static func == (a: HydraCore.HydraInboxError, b: HydraCore.HydraInboxError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol UserDetailsGenerator {
  var customerId: Swift.String { get set }
  var firstName: Swift.String? { get set }
  var lastName: Swift.String? { get set }
  var email: Swift.String? { get set }
  var phone: Swift.String? { get set }
}
public struct UserDetails : HydraCore.UserDetailsGenerator {
  public var customerId: Swift.String
  public var firstName: Swift.String?
  public var lastName: Swift.String?
  public var email: Swift.String?
  public var phone: Swift.String?
  public init(customerId: Swift.String, firstName: Swift.String? = nil, lastName: Swift.String? = nil, email: Swift.String? = nil, phone: Swift.String? = nil)
}
public enum HTTPMethod : Swift.String {
  case get
  case post
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol GeographicDataGenerator {
  var country: Swift.String? { get set }
  var city: Swift.String? { get set }
  var countryCode: Swift.String? { get set }
  var timeZone: Swift.String? { get set }
  func update(with geoData: (any HydraCore.GeographicDataGenerator)?)
}
public class GeoData : HydraCore.GeographicDataGenerator {
  public var country: Swift.String?
  public var countryCode: Swift.String?
  public var city: Swift.String?
  public var timeZone: Swift.String?
  public init(country: Swift.String? = nil, countryCode: Swift.String? = nil, city: Swift.String? = nil, timeZone: Swift.String? = nil)
  public func update(with geoData: (any HydraCore.GeographicDataGenerator)?)
  @objc deinit
}
public enum HydraAPIError : Swift.Error, Swift.Equatable {
  case invalidURL
  case invalidURLRequest
  case unAuthorised
  case noResponse
  case sslPinningFailed
  case timeOut
  case noInternet
  case httpClientStatusCode(Swift.Int)
  case httpServerStatusCode(Swift.Int)
  case httpStausCode(Swift.Int)
  case unknown
  public static func == (a: HydraCore.HydraAPIError, b: HydraCore.HydraAPIError) -> Swift.Bool
}
extension HydraCore.HydraAPIError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var code: Swift.Int {
    get
  }
}
extension Foundation.Data {
  public func toDictionary() throws -> HydraCore.JSONDictionary?
}
extension HydraCore.HydraConstants {
  public enum URLRequestHeaders {
    public static let authEventReportHeaders: [Swift.String : Swift.String]
  }
  public static func baseURL(for account: Swift.String) -> Swift.String
  public static func SSLKeyHash(for account: Swift.String) -> Swift.String
}
public enum HydraLoggerType : Swift.Int {
  case console
  case remote
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension HydraCore.HydraLog : Swift.Identifiable {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<HydraCore.HydraLog>
  @objc @NSManaged dynamic public var logId: Foundation.UUID {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var level: Swift.Int {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var message: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var timeStamp: Foundation.Date {
    @objc get
    @objc set
  }
  public typealias ID = Swift.ObjectIdentifier
}
public protocol ConfigurationGenerator {
  var accountID: Swift.String { get set }
  var customerId: Swift.String { get set }
  var server: HydraCore.ServerConfig { get set }
  func update(with config: any HydraCore.ConfigurationGenerator)
}
extension HydraCore.ConfigurationGenerator {
  public static func GenerateConfiguration(with config: any HydraCore.ConfigurationGenerator) throws -> any HydraCore.ConfigurationGenerator
}
@_hasMissingDesignatedInitializers public class HydraConfiguration : HydraCore.ConfigurationGenerator {
  public typealias MockType = HydraCore.HydraConfiguration
  public var accountID: Swift.String
  public var server: HydraCore.ServerConfig
  public var customerId: Swift.String
  convenience public init(accountID: Swift.String, customerId: Swift.String, server: HydraCore.ServerConfig = .server1) throws
  public func update(with config: any HydraCore.ConfigurationGenerator)
  @objc deinit
}
extension HydraCore.HydraConfiguration {
  public static func getMockObject() -> HydraCore.HydraConfiguration?
}
extension HydraCore.HydraConfiguration {
  public func isIdentical(with config: HydraCore.HydraConfiguration) -> Swift.Bool
}
public protocol APIEndPointGenerator {
  var baseURL: Swift.String { get set }
  var SSLKeyHash: Swift.String { get set }
  init(baseURL url: Swift.String, SSLKeyHash keyhash: Swift.String)
}
extension HydraCore.APIEndPointGenerator {
  public static func generateAPIEndpoint(baseURL: Swift.String, SSLKeyHash: Swift.String) -> any HydraCore.APIEndPointGenerator
  public func isValid() -> Swift.Result<Swift.Bool, HydraCore.HydraError>
}
public struct HydraAPIEndPoint {
  public var baseURL: Swift.String
  public var SSLKeyHash: Swift.String
  public init(baseURL url: Swift.String = "", SSLKeyHash keyhash: Swift.String = "")
  public init(baseURL url: Swift.String = "", SSLKeyHash keyhash: Swift.String = "", delayIntervals: [Foundation.TimeInterval] = [])
  public mutating func next(afterIndex idx: Swift.Int) -> Foundation.TimeInterval
  public func next(delayAfter delay: Foundation.TimeInterval, errorCode: Swift.Int) -> Foundation.TimeInterval
  public mutating func nextDelayAfterCurrent() -> Foundation.TimeInterval
  public mutating func resetDelayCounter()
}
extension HydraCore.APIEndPointGenerator {
  public static func defaultValues() -> any HydraCore.APIEndPointGenerator
}
extension HydraCore.APIEndPointGenerator where Self == HydraCore.HydraAPIEndPoint {
  public func isValid() -> Swift.Result<HydraCore.HydraAPIEndPoint, HydraCore.HydraError>
}
extension HydraCore.HydraError {
  public static var InvalidAPIEndPointError: HydraCore.HydraError
}
@_hasMissingDesignatedInitializers public class UserNotificationPreferences {
  @objc deinit
}
public typealias JSONDictionary = [Swift.String : Any]
public typealias Attributes = HydraCore.JSONDictionary
public typealias EventDataType = HydraCore.JSONDictionary
public typealias JSON = Foundation.Data
public enum HydraConstants {
  public static let CarrierInformationUnavailable: Swift.String
  public static let crossChar: Swift.String
  public static let checkMarkChar: Swift.String
  public static let startMarkChar: Swift.String
  public static let endMarkChar: Swift.String
  public static let signPostChar: Swift.String
  public static let fcmGateway: Swift.String
  public enum Keys {
  }
}
extension HydraCore.HydraConstants.Keys {
  public enum APIRequestKeys {
    public static let accountID: Swift.String
    public static let clientSecret: Swift.String
    public static let clientID: Swift.String
    public static let customData: Swift.String
    public static let cuid: Swift.String
    public static let scope: Swift.String
    public static let result: Swift.String
    public static let senderId: Swift.String
    public static let type: Swift.String
    public static let senderSource: Swift.String
    public static let custom: Swift.String
    public static let firstName: Swift.String
    public static let lastName: Swift.String
    public static let phone: Swift.String
    public static let email: Swift.String
    public static let autoGenerated: Swift.String
    public static let userPreferences: Swift.String
    public static let bundleIdentifier: Swift.String
    public static let osName: Swift.String
    public static let grantType: Swift.String
    public static let gateway: Swift.String
    public static let messageId: Swift.String
    public static let interfaceId: Swift.String
    public static let tokens: Swift.String
    public static let rating: Swift.String
    public static let feedback: Swift.String
    public static let feedbackOptions: Swift.String
    public static let triggerEventName: Swift.String
    public static let subscriptions: Swift.String
    public static let channel: Swift.String
    public static let priority: Swift.String
  }
}
public enum NotificationPayloadKeys {
  public static let type: Swift.String
  public static let action: Swift.String
  public static let actionText: Swift.String
  public static let title: Swift.String
  public static let message: Swift.String
  public static let image: Swift.String
  public static let cta: Swift.String
  public static let style: Swift.String
  public static let ctas: Swift.String
  public static let attributes: Swift.String
  public static let eventName: Swift.String
  public static let priority: Swift.String
  public static let validity: Swift.String
  public static let campaignId: Swift.String
  public static let variationId: Swift.String
  public static let body: Swift.String
  public static let expandableDetails: Swift.String
  public static let trigger: Swift.String
  public static let gateway: Swift.String
  public static let messageId: Swift.String
  public static let accountId: Swift.String
  public static let imageIdentifier: Swift.String
}
public enum HydraDLREvents : Swift.String {
  case pushNotificationReceived
  case pushNotificationClick
  case pushNotificationView
  case pushNotificationClose
  case pushNotificationRejected
  case pushNotificationDeleted
  case inAppMessageShown
  case inAppMessageClicked
  case inAppMessageRejected
  case inAppMessageDismissed
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HydraBehavioralEvents : Swift.String {
  case inAppMessageRating
  case inAppMessageFeedback
  case inAppMessageClose
  case inAppMessageAppRating
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum NotificationEventResult : Swift.String {
  case success
  case scopeNotAvailable
  case messageNotAvailable
  case permissionNotGranted
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HydraNotificationAction {
  case read
  case delete
  public static func == (a: HydraCore.HydraNotificationAction, b: HydraCore.HydraNotificationAction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public let Logger: HydraCore.HydraLogger
public enum CTAActionType : Swift.String {
  case external
  case deepLink
  case rating
  case feedback
  case appRating
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public var imageDirectory: Foundation.URL?
extension Foundation.NSNotification.Name {
  public static let didCaptureInAppTrigger: Foundation.Notification.Name
}
extension HydraCore.HydraConstants {
  public enum InAppTriggers : Swift.String {
    case inAppRating
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension HydraCore.HydraConstants {
  public enum PullMessagesConstants {
  }
}
@objc @_inheritsConvenienceInitializers public class StringValueTransformer : Foundation.ValueTransformer {
  @objc override dynamic public func transformedValue(_ value: Any?) -> Any?
  @objc override dynamic public func reverseTransformedValue(_ value: Any?) -> Any?
  @objc override dynamic public class func allowsReverseTransformation() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
extension HydraCore.StringValueTransformer {
  public static func register()
}
public protocol RemoteLogProtocol {
  var logId: Foundation.UUID { get set }
  var timeStamp: Foundation.Date { get set }
  var message: Swift.String { get set }
  var logLevel: HydraCore.LogLevel { get set }
  var level: Swift.String { get set }
}
public actor HydraCryptoManager {
  public init()
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
public typealias DatabaseCompletionHandler = (Swift.Result<Swift.Bool, any Swift.Error>) -> Swift.Void
public typealias FetchSingleRecordCompletionHandler<T> = (Swift.Result<T?, any Swift.Error>) -> Swift.Void
public typealias DatabaseFetchCountCompletionHandler = (Swift.Result<Swift.Int, any Swift.Error>) -> Swift.Void
public typealias DatabaseFetchRecordsCompletionHandler<T> = (Swift.Result<[T], any Swift.Error>) -> Swift.Void
public typealias CompletionHandler = (Swift.Bool) -> Swift.Void
public typealias FetchRecordsCompletionHandler<T> = (Swift.Array<T>) -> Swift.Void
public typealias FetchCountCompletionHandler = (Swift.Int) -> Swift.Void
public typealias InsertNotificationCompletionHandler = ((Swift.Int, Swift.Bool)) -> Swift.Void
public class BaseRepository<T> where T : CoreData.NSManagedObject {
  final public let entity: T.Type
  final public let store: Swift.String
  final public let mom: CoreData.NSManagedObjectModel
  public var container: CoreData.NSPersistentContainer?
  public var sharedAppGroupIdentifier: Swift.String?
  public var inferMappingModelAutomatically: Swift.Bool
  public var name: Swift.String {
    get
    set
  }
  public var descriptions: [CoreData.NSPersistentStoreDescription]? {
    get
    set
  }
  public var testDescriptions: [CoreData.NSPersistentStoreDescription]? {
    get
    set
  }
  public var viewContext: CoreData.NSManagedObjectContext? {
    get
  }
  public var backgroundContext: CoreData.NSManagedObjectContext?
  public init(store: Swift.String, mom: CoreData.NSManagedObjectModel, env: HydraCore.Env = .dev, shouldInferMappingModelAutomatically: Swift.Bool = true, sharedAppGroupIdentifier: Swift.String? = nil)
  public func initPersistentContainer(env: HydraCore.Env)
  @objc deinit
}
extension HydraCore.HydraNotification {
  public enum Property : Swift.String {
    case campaignId
    case body
    case cuid
    case custom
    case type
    case gateway
    case validity
    case priority
    case expandableDetails
    case scope
    case senderID
    case senderSource
    case variationId
    case createdAt
    case isRead
    case messageId
    case imageIdentifier
    case accountId
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension HydraCore.HydraLog {
  public enum Property : Swift.String {
    case logId
    case level
    case message
    case timeStamp
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension HydraCore.HydraConstants {
  public enum API {
    public static let accessTokenPath: Swift.String
    public static let authorizePath: Swift.String
    public static let setOfRetriableStatusCodes: Swift.Set<Swift.Int>
    public static let setOfNonRetriableStatusCodes: Swift.Set<Swift.Int>
  }
}
extension HydraCore.HydraConstants.API {
  public static var DefaultRequestTimeout: Foundation.TimeInterval
  public static var endPointMap: [Swift.String : HydraCore.HydraAPIEndPoint]
  public static func getEndPoint(for account: Swift.String) -> HydraCore.HydraAPIEndPoint?
}
extension Foundation.Bundle {
  public enum Keys {
  }
  public var icon: UIKit.UIImage? {
    get
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  public var isNil: Swift.Bool {
    get
  }
}
#else
extension Swift.Optional {
  public var isNil: Swift.Bool {
    get
  }
}
#endif
public protocol HydraPushNotificationProtocol : AnyObject {
  func process(cta: HydraCore.CTA, notificationPayload payload: Any) -> Swift.Bool
  func pullUndeliveredNotifications()
}
extension HydraCore.HydraPushNotificationProtocol {
  public func pullUndeliveredNotifications()
}
public enum DBStorageType {
  case persistent, inMemory
  public static func == (a: HydraCore.DBStorageType, b: HydraCore.DBStorageType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Constants {
}
public typealias NetworkManager = HydraCore.HydraNetworkManager
public class HydraNetworkManager {
  public init()
  public func callAPI(withRequest request: any HydraCore.HydraAPIRequestGenerator) async throws -> (any HydraCore.HydraResponseGenerator)?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class HydraError : Foundation.NSError, @unchecked Swift.Sendable {
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public init(domain: Swift.String, code: Swift.Int, userInfo dict: [Swift.String : Any]? = nil)
  @objc deinit
}
public enum HydraErrorFactory {
  public static func generateError(domain: Swift.String, code: Swift.Int, userInfo: [Swift.String : Any]? = nil) -> HydraCore.HydraError
  public static func generateError(domain: Swift.String, userInfo: [Swift.String : Any]? = nil) -> HydraCore.HydraError
  public static func generateError(domain: Swift.String, code: Swift.Int, userInfo: [Swift.String : Any]? = nil) -> Foundation.NSError
  public static func generateError(fromNSError err: Foundation.NSError) -> HydraCore.HydraError
  public static func generateError(fromAPIError err: HydraCore.HydraAPIError) -> HydraCore.HydraError
}
@_hasMissingDesignatedInitializers final public class Hydra {
  public static func generate(with configuration: any HydraCore.ConfigurationGenerator, geoData: (any HydraCore.GeographicDataGenerator)? = nil, supportsPushNotifications: Swift.Bool = false, deviceScreenInfo: HydraCore.DeviceScreenInfo? = nil, inboxCoreConfig: (any HydraCore.HydraInboxCoreConfigGenerator)? = nil, configuredFor env: HydraCore.Env = .dev, consoleLogLevel level: HydraCore.LogLevel = .debug, remoteLogLevel: HydraCore.LogLevel = .none) throws -> HydraCore.Hydra
  public static func getSharedUserDefaults() -> Foundation.UserDefaults?
  final public func update(customerID id: Swift.String)
  final public func customerId() -> Swift.String?
  final public func update(deviceToken id: Swift.String)
  final public func update(interfaceID id: Swift.String) async
  final public func update(notificationSupport status: Swift.Bool)
  final public func getCurrentNotificationSupport() -> Swift.Bool
  final public func updateUserNotificationSettingsFor(promoPushOpted: Swift.Bool, transPushOpted: Swift.Bool)
  final public func getInterfaceId() async -> Swift.String?
  final public func configuration() -> any HydraCore.ConfigurationGenerator
  @objc deinit
}
extension HydraCore.Hydra {
  final public func reportBehavioralEvent(name: Swift.String, customAttributes attributes: HydraCore.Attributes)
  final public func reportDLREvent(dlrEventType type: HydraCore.HydraDLREvents, customAttributes attributes: HydraCore.Attributes, completion: HydraCore.CompletionHandler? = nil)
}
extension HydraCore.Hydra {
  final public func reportUserSignUP(data: any HydraCore.UserDetailsGenerator, customData: HydraCore.Attributes)
  final public func reportUserSignIn(data: any HydraCore.UserDetailsGenerator, customData: HydraCore.Attributes)
  final public func reportUserSignOut(customData: [Swift.String : Any])
  final public func reportUserProfileUpdate(data: any HydraCore.UserDetailsGenerator, customData: HydraCore.Attributes, subscriptions: [Any]? = nil)
  final public func reportUserSettingsUpdate(subscriptions: [Any]? = nil)
  final public func reportUserPreferencesUpdate(subscriptions: [Any]? = nil)
}
extension HydraCore.Hydra {
  final public func checkForIdenticalConfig(config: HydraCore.HydraConfiguration) -> Swift.Bool
  public static func getHydra(for accountId: Swift.String) -> HydraCore.Hydra?
}
extension HydraCore.Hydra {
  final public func setHydraInboxCoreDelegate(delegate: any HydraCore.HydraInboxCoreProtocol)
  final public func getHydraInboxCoreDelegate() -> (any HydraCore.HydraInboxCoreProtocol)?
}
extension HydraCore.Hydra {
  final public func setHydraPushNotificationDelegate(delegate: any HydraCore.HydraPushNotificationProtocol)
  final public func getHydraPushNotificationDelegate() -> (any HydraCore.HydraPushNotificationProtocol)?
}
extension HydraCore.Hydra {
  public static func getAppGroupIdentifier() -> Swift.String?
}
extension HydraCore.Hydra {
  final public func update(configuration config: any HydraCore.ConfigurationGenerator)
  final public func update(geoData geo: (any HydraCore.GeographicDataGenerator)?)
  final public func update(screenInformation deviceScreenInfo: (any HydraCore.DeviceScreenInfoGenerator)?)
  final public func update(inboxConfiguration inboxConfig: (any HydraCore.HydraInboxCoreConfigGenerator)?)
}
@_inheritsConvenienceInitializers @objc(Event) public class Event : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension Foundation.DateFormatter {
  public static var HydraStandardDateFormatter: Foundation.DateFormatter
}
extension Foundation.Date {
  public static func getDateForLastSeenField() -> Swift.String
  public func getStringifiedGenerationDate() -> Swift.String
  public func timeStamp() -> Swift.String
}
extension CoreData.NSManagedObject {
  public class var entityName: Swift.String {
    get
  }
}
public protocol HydraImageViewProtocol : AnyObject {
  func didTapOnImage()
}
extension HydraCore.HydraNotification : Swift.Identifiable {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<HydraCore.HydraNotification>
  @objc @NSManaged dynamic public var campaignId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var body: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var cuid: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var custom: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var type: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var gateway: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var priority: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var validity: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var expandableDetails: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var scope: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var senderID: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var senderSource: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var variationId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var createdAt: Foundation.Date {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var isRead: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var messageId: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var imageIdentifier: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var accountId: Swift.String {
    @objc get
    @objc set
  }
  public typealias ID = Swift.ObjectIdentifier
}
@_Concurrency.MainActor @preconcurrency public struct HydraImageView : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(withImageURL url: Foundation.URL?, imageIdentifier identifier: Swift.String?, placeholderImage image: UIKit.UIImage?, delegate imageDelegate: (any HydraCore.HydraImageViewProtocol)?, imageAspectRatio: SwiftUICore.ContentMode = .fit, asynchronousDownload async: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s9HydraCore0A9ImageViewV4bodyQrvp", 0) __
}
extension HydraCore.Event {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<HydraCore.Event>
  @objc @NSManaged dynamic public var accountID: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var attributes: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var createdAt: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var eventID: Foundation.UUID? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var eventType: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var name: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var customerID: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var requestID: Foundation.UUID? {
    @objc get
    @objc set
  }
}
extension HydraCore.Event : Swift.Identifiable {
  public typealias ID = Swift.ObjectIdentifier
}
public struct DummyNotificationPayload {
  public static func parseJSON(fileName: Swift.String) -> [Swift.String : Any]
  public static func getJSONData(fileName: Swift.String) -> Foundation.Data?
  public static func getDummyNotificationPayload(withDeepLink deepLinkEnabled: Swift.Bool = false) -> HydraCore.HydraNotificationPayload
}
public enum LogLevel : Swift.Int {
  case none
  case debug
  case info
  case warning
  case error
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class HydraLogger {
  @objc deinit
  final public func updateLogLevel(level: HydraCore.LogLevel, for type: HydraCore.HydraLoggerType)
  final public func debug(_ message: Swift.String, file: Swift.String = #file, function: Swift.String = #function, filename: Swift.String = #file, line: Swift.UInt = #line, column: Swift.UInt = #column, type: os.OSLogType = .default, remoteLog: Swift.Bool = true)
  final public func error(_ message: Swift.String, file: Swift.String = #file, function: Swift.String = #function, filename: Swift.String = #file, line: Swift.UInt = #line, column: Swift.UInt = #column, type: os.OSLogType = .default, remoteLog: Swift.Bool = true)
  final public func info(_ message: Swift.String, file: Swift.String = #file, function: Swift.String = #function, filename: Swift.String = #file, line: Swift.UInt = #line, column: Swift.UInt = #column, type: os.OSLogType = .default, remoteLog: Swift.Bool = true)
}
public protocol HydraInboxCoreConfigGenerator {
  var maximumNotificationCount: Swift.Int? { get set }
  var hydraConfig: any HydraCore.ConfigurationGenerator { get set }
  func update(with config: (any HydraCore.HydraInboxCoreConfigGenerator)?)
}
extension HydraCore.Hydra {
  final public func openExternal(url: Swift.String)
  final public func performCTAAction(cta: HydraCore.CTA, notificationPayload payload: Any)
  final public func handleCTA(cta: HydraCore.CTA)
  final public func handleDeleteAllNotificationsFromNotificationCenter(completion: HydraCore.DatabaseCompletionHandler? = nil)
  final public func handleNotification(notification: HydraCore.HydraNotificationPayload, action: HydraCore.HydraNotificationAction, completion: HydraCore.DatabaseCompletionHandler? = nil)
  final public func deleteAllNotifications(completion: HydraCore.DatabaseCompletionHandler? = nil)
  final public func getUnreadNotificationCount(completion: @escaping HydraCore.FetchCountCompletionHandler)
  final public func getNotifications(maxNotificationsCount: Swift.Int?, completion: @escaping HydraCore.FetchRecordsCompletionHandler<HydraCore.HydraNotificationPayload>)
  public static func getNotificationEventAttributes(with notificationPayload: HydraCore.HydraNotificationPayload, result: HydraCore.NotificationEventResult) -> HydraCore.Attributes
  public static func checkInboxAvailibility() -> Swift.Bool
  public static func isValidNotification(notification: HydraCore.HydraNotificationPayload) -> Swift.Bool
  public static func notificationAttributes(from message: HydraCore.HydraNotificationPayload, isRead: Swift.Bool = false) -> HydraCore.Attributes
  public static func getUnreadNotificationsCount(notification: HydraCore.HydraNotificationPayload, completion: HydraCore.FetchCountCompletionHandler? = nil)
  public static func insertNotification(_ notification: HydraCore.HydraNotificationPayload, isRead: Swift.Bool = false, reportDLREvent sendDLR: Swift.Bool, updateBadge: Swift.Bool = false, completion: HydraCore.CompletionHandler? = nil)
  public static func insertInboxNotifications(with notifications: [HydraCore.HydraNotificationPayload], completion: HydraCore.FetchRecordsCompletionHandler<HydraCore.HydraNotificationPayload>? = nil)
  public static func scheduleDLREvent(dlr: HydraCore.HydraDLREvents, payload: HydraCore.HydraNotificationPayload, completion: HydraCore.CompletionHandler? = nil)
  public static func updateBadgeCount(count: Swift.Int)
  public static func isRunningUnitTests() -> Swift.Bool
}
extension HydraCore.Hydra {
  final public func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithToken token: Foundation.Data)
}
public enum HydraNotificationType : Swift.String {
  case push
  case inapp
  case notificationCenter
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct CTA {
  public var actionText: Swift.String
  public var action: Swift.String
  public var type: Swift.String
  public var isEmpty: Swift.Bool {
    get
  }
  public init(actionText: Swift.String = "", action: Swift.String = "", type: Swift.String = "")
}
public struct Body {
  public var textRepresentation: Swift.String
  public var title: Swift.String
  public var message: Swift.String
  public var image: Swift.String
  public var cta: HydraCore.CTA
  public var isEmpty: Swift.Bool {
    get
  }
  public static func generate(from str: Swift.String) -> HydraCore.Body
}
public enum ExpandableDetailsStyle : Swift.String {
  case bigText
  case bigPicture
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct ExpandableDetails {
  public var textRepresentation: Swift.String
  public var style: HydraCore.ExpandableDetailsStyle
  public var message: Swift.String
  public var image: Swift.String
  public var ctas: [HydraCore.CTA]
  public var isEmpty: Swift.Bool {
    get
  }
  public static func generate(from str: Swift.String) -> HydraCore.ExpandableDetails
}
public enum NotificationGateway : Swift.String {
  case fcm
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct HydraNotificationPayload {
  public var cuid: Swift.String
  public var scope: Swift.String
  public var campaignId: Swift.String!
  public var variationId: Swift.String!
  public var senderID: Swift.String
  public var senderSource: Swift.String
  public var custom: [[Swift.String : Any]]
  public var priority: Swift.String
  public var validity: Swift.String
  public var messageId: Swift.String
  public var gateway: HydraCore.NotificationGateway
  public var body: HydraCore.Body
  public var expandableDetails: HydraCore.ExpandableDetails
  public var isRead: Swift.String
  public var imageIdentifier: Swift.String
  public var createdAt: Foundation.Date?
  public var accountId: Swift.String
  public var type: HydraCore.HydraNotificationType
  public var userInfo: [Swift.AnyHashable : Any]
  public static func generate(from userInfo: [Swift.AnyHashable : Any]) -> HydraCore.HydraNotificationPayload
  public func getImageURL() -> Foundation.URL?
  public func getImageURLForExpandable() -> Foundation.URL?
  public func getJSON() -> [Swift.String : Any]
}
extension HydraCore.HydraNotificationPayload {
  public static func generate(from dbObj: HydraCore.HydraNotification) -> HydraCore.HydraNotificationPayload
}
public enum Env : Swift.String {
  case dev
  case unittest
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension SwiftUICore.Color {
  public init(hex: Swift.String)
}
extension SwiftUICore.Color {
  public func uiColor() -> UIKit.UIColor
}
extension UIKit.UIColor {
  public func color() -> SwiftUICore.Color?
}
@_inheritsConvenienceInitializers @objc(HydraNotification) public class HydraNotification : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ImageUtility {
  @discardableResult
  public static func downloadImage(with imageURL: Foundation.URL, imageIdentifier identifier: Swift.String?) async throws -> Foundation.Data?
  @discardableResult
  public static func cacheImage(with data: Foundation.Data, imageIdentifier identifier: Swift.String, imageExtension: Swift.String) -> Foundation.URL?
  public static func cachedImageData(for identifier: Swift.String, imageExtension: Swift.String) -> Foundation.Data?
  public static func getDowloadedImage(withImageIdentifier identifier: Swift.String, imageExtension: Swift.String) -> Any?
  public static func removeCachedImage(withImageIdentifier identifier: Swift.String, imageExtension: Swift.String)
  public static func removeAllCachedImages()
  @objc deinit
}
extension HydraCore.ImageUtility {
  public static func checkIfGifFile(with fileExtension: Swift.String) -> Swift.Bool
  public static func isGifFile(with url: Foundation.URL) -> Swift.Bool
  public static func fileExtension(from url: Foundation.URL) -> Swift.String?
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension Network.NWInterface.InterfaceType : @retroactive Swift.CaseIterable {
  public static var allCases: [Network.NWInterface.InterfaceType]
  @available(iOS 12.0, tvOS 12.0, watchOS 5.0, macOS 10.14, *)
  public typealias AllCases = [Network.NWInterface.InterfaceType]
}
#else
extension Network.NWInterface.InterfaceType : Swift.CaseIterable {
  public static var allCases: [Network.NWInterface.InterfaceType]
  @available(iOS 12.0, tvOS 12.0, watchOS 5.0, macOS 10.14, *)
  public typealias AllCases = [Network.NWInterface.InterfaceType]
}
#endif
@_hasMissingDesignatedInitializers final public class NetworkMonitor {
  public static let shared: HydraCore.NetworkMonitor
  final public class func isConnectedToNetwork() -> Swift.Bool
  @objc deinit
}
public protocol PostRemoteLogRequestProtocol : HydraCore.HydraAPIRequestGenerator {
  mutating func sendLogs(withBody dict: HydraCore.JSONDictionary) async throws -> (any HydraCore.HydraResponseGenerator)?
  func logsSent()
}
public protocol DBDefaultsGenerator {
  static var defaultPersistentStoreTimeOut: Foundation.TimeInterval { get }
  static var defaultStoreName: Swift.String { get }
  static var defaultfModelFileName: Swift.String { get }
  static var defaultModelFileExtension: Swift.String { get }
  static var defaultEnityName: Swift.String { get }
  static var defaultBundle: Foundation.Bundle { get }
}
extension HydraCore.DBDefaultsGenerator {
  public static var defaultModelFileURL: Foundation.URL {
    get
  }
  public static var defaultMOM: CoreData.NSManagedObjectModel! {
    get
  }
}
extension HydraCore.HydraConstants.Keys {
  public enum SystemData {
    public static let brand: Swift.String
    public static let osName: Swift.String
    public static let osVersion: Swift.String
    public static let appVersion: Swift.String
    public static let appBunldeID: Swift.String
    public static let sdkVersion: Swift.String
    public static let pushReachable: Swift.String
    public static let lastSeen: Swift.String
    public static let timeZoneName: Swift.String
    public static let carrier: Swift.String
    public static let country: Swift.String
    public static let city: Swift.String
    public static let countryCode: Swift.String
    public static let model: Swift.String
    public static let deviceID: Swift.String
    public static let advertID: Swift.String
    public static let interfaceID: Swift.String
    public static let viewPortWidth: Swift.String
    public static let viewPortHeight: Swift.String
  }
}
public protocol EventProtocol {
  var eventID: Foundation.UUID { get set }
  var generationDate: Foundation.Date { get set }
  var name: Swift.String { get set }
  var attributes: HydraCore.Attributes? { get set }
  var type: Swift.String { get set }
  var custID: Swift.String { get set }
  var isInSync: Swift.Bool { get set }
}
extension HydraCore.HydraGifImageView : Swift.Sendable {}
extension HydraCore.HydraDatabaseError : Swift.Hashable {}
extension HydraCore.HydraAuthFlowError : Swift.Hashable {}
extension HydraCore.HydraFileManagerError : Swift.Equatable {}
extension HydraCore.HydraFileManagerError : Swift.Hashable {}
extension HydraCore.HydraImageDownloadError : Swift.Equatable {}
extension HydraCore.HydraImageDownloadError : Swift.Hashable {}
extension HydraCore.HydraInboxError : Swift.Equatable {}
extension HydraCore.HydraInboxError : Swift.Hashable {}
extension HydraCore.HTTPMethod : Swift.Equatable {}
extension HydraCore.HTTPMethod : Swift.Hashable {}
extension HydraCore.HTTPMethod : Swift.RawRepresentable {}
extension HydraCore.HydraLoggerType : Swift.Equatable {}
extension HydraCore.HydraLoggerType : Swift.Hashable {}
extension HydraCore.HydraLoggerType : Swift.RawRepresentable {}
extension HydraCore.HydraAPIEndPoint : HydraCore.APIEndPointGenerator {}
extension HydraCore.HydraDLREvents : Swift.Equatable {}
extension HydraCore.HydraDLREvents : Swift.Hashable {}
extension HydraCore.HydraDLREvents : Swift.RawRepresentable {}
extension HydraCore.HydraBehavioralEvents : Swift.Equatable {}
extension HydraCore.HydraBehavioralEvents : Swift.Hashable {}
extension HydraCore.HydraBehavioralEvents : Swift.RawRepresentable {}
extension HydraCore.NotificationEventResult : Swift.Equatable {}
extension HydraCore.NotificationEventResult : Swift.Hashable {}
extension HydraCore.NotificationEventResult : Swift.RawRepresentable {}
extension HydraCore.HydraNotificationAction : Swift.Equatable {}
extension HydraCore.HydraNotificationAction : Swift.Hashable {}
extension HydraCore.CTAActionType : Swift.Equatable {}
extension HydraCore.CTAActionType : Swift.Hashable {}
extension HydraCore.CTAActionType : Swift.RawRepresentable {}
extension HydraCore.HydraConstants.InAppTriggers : Swift.Equatable {}
extension HydraCore.HydraConstants.InAppTriggers : Swift.Hashable {}
extension HydraCore.HydraConstants.InAppTriggers : Swift.RawRepresentable {}
extension HydraCore.HydraNotification.Property : Swift.Equatable {}
extension HydraCore.HydraNotification.Property : Swift.Hashable {}
extension HydraCore.HydraNotification.Property : Swift.RawRepresentable {}
extension HydraCore.HydraLog.Property : Swift.Equatable {}
extension HydraCore.HydraLog.Property : Swift.Hashable {}
extension HydraCore.HydraLog.Property : Swift.RawRepresentable {}
extension HydraCore.DBStorageType : Swift.Equatable {}
extension HydraCore.DBStorageType : Swift.Hashable {}
extension HydraCore.HydraImageView : Swift.Sendable {}
extension HydraCore.LogLevel : Swift.Equatable {}
extension HydraCore.LogLevel : Swift.Hashable {}
extension HydraCore.LogLevel : Swift.RawRepresentable {}
extension HydraCore.HydraNotificationType : Swift.Equatable {}
extension HydraCore.HydraNotificationType : Swift.Hashable {}
extension HydraCore.HydraNotificationType : Swift.RawRepresentable {}
extension HydraCore.ExpandableDetailsStyle : Swift.Equatable {}
extension HydraCore.ExpandableDetailsStyle : Swift.Hashable {}
extension HydraCore.ExpandableDetailsStyle : Swift.RawRepresentable {}
extension HydraCore.NotificationGateway : Swift.Equatable {}
extension HydraCore.NotificationGateway : Swift.Hashable {}
extension HydraCore.NotificationGateway : Swift.RawRepresentable {}
extension HydraCore.Env : Swift.Equatable {}
extension HydraCore.Env : Swift.Hashable {}
extension HydraCore.Env : Swift.RawRepresentable {}
